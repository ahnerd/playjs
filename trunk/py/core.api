<?xml version="1.0" encoding="gb2312"?>
<doc language="Javascript" create="2011/7/24 12:18:07">
  <summary>Py.Core for Javascript</summary>
  <sources default="1">
    <source id="0" path="../../../window/fun/PyDoc/bin/Debug/define.js" />
    <source id="1" path="system.js" author="xuld" copyright="2009-2011 Py.Core Team">
      <summary>系统核心的核心部分。</summary>
    </source>
  </sources>
  <members>
    <class name="Object" source="-1">
      <method name="extend" attribute="static" id="0">
        <summary>复制对象的所有属性到其它对象。</summary>
        <remarks>&lt;p&gt;
这个函数是实现继承的核心。
&lt;/p&gt;
&lt;p&gt;
在 Javascript 中，继承是依靠原型链实现的， 这个函数仅仅是对它的包装，而没有做额外的动作。
&lt;/p&gt;
&lt;p&gt;
成员中的  constructor 成员 被认为是构造函数。
&lt;/p&gt;
&lt;p&gt;
这个函数实现的是 单继承。如果子类有定义构造函数，则仅调用子类的构造函数，否则调用父类的构造函数。
&lt;/p&gt;
&lt;p&gt;
要想在子类的构造函数调用父类的构造函数，可以使用  &lt;link&gt;Py.Object.prototype.base&lt;/link&gt; 。
&lt;/p&gt;
&lt;p&gt;
这个函数返回的类实际是一个函数，但它被使用 Py.Object 修饰过。
&lt;/p&gt;
&lt;p&gt;
由于原型链的关系， 肯能存在共享的引用。
如: 类 A ，  A.prototype.c = [];
那么，A的实例 b , d 都有 c 成员， 但它们共享一个   A.prototype.c 成员。
这显然是不正确的。所以你应该把 参数 quick 置为 false ， 这样， A创建实例的时候，会自动解除共享的引用成员。
当然，这是一个比较费时的操作，因此，默认  quick 是 true 。
&lt;/p&gt;
&lt;p&gt;
你也可以把动态成员的定义放到 构造函数， 如: this.c = [];
这是最好的解决方案。
&lt;/p&gt;</remarks>
        <seealso cref="Object.extendIf" />
        <example>&lt;code&gt;
var a = {v: 3}, b = {g: 2};
Object.extend(a, b);
trace(a); // {v: 3, g: 2}
&lt;/code&gt;</example>
        <returns type="Object">复制后的对象 (dest)。</returns>
        <param name="dest" type="Function">复制目标。</param>
        <param name="obj" type="Object">要复制的内容。</param>
      </method>
      <method name="implement" attribute="static" id="1">
        <summary>扩展当前类的动态方法。</summary>
        <seealso cref="Py.Object.implementIf" />
        <example>&lt;code&gt;
Number.implement({
sin: function() {
return Math.sin(this);
}
});
(1).sin();  //  Math.sin(1);
&lt;/code&gt;</example>
        <returns type="">this</returns>
        <param name="obj" type="Object">成员。</param>
      </method>
      <method name="implementIf" attribute="static" id="2">
        <summary>如果不存在成员, 扩展当前类的动态方法。</summary>
        <seealso cref="Py.Object.implement" />
        <returns type="">this</returns>
        <param name="obj" type="Object">成员。</param>
      </method>
      <method name="addEvents" attribute="static" id="3">
        <summary>为当前类添加事件。</summary>
        <remarks>&lt;p&gt;
由于一个类的事件是按照 xType 属性存放的，拥有相同  xType 的类将有相同的事件，为了避免没有 xType 属性的类出现事件冲突， 这个方法会自动补全  xType 属性。
&lt;/p&gt;
&lt;p&gt;
这个函数是实现自定义事件的关键。
&lt;/p&gt;
&lt;p&gt;
addEvents 函数的参数是一个事件信息，格式如:  {click: { add: ..., remove: ..., initEvent: ..., trigger: ...} 。
其中 click 表示事件名。一般建议事件名是小写的。
&lt;/p&gt;
&lt;p&gt;
一个事件有多个相应，分别是: 绑定(add), 删除(remove), 触发(trigger), 初始化事件参数(initEvent)
&lt;/p&gt;
&lt;/p&gt;
当用户使用   o.on('事件名', 函数)  时， 系统会判断这个事件是否已经绑定过，
如果之前未绑定事件，则会创建新的函数 evtTrigger，
evtTrigger 函数将遍历并执行 evtTrigger.handlers 里的成员, 如果其中一个函数执行后返回 false， 则中止执行，并返回 false， 否则返回 true。
evtTrigger.handlers 表示 当前这个事件的所有实际调用的函数的数组。 evtTrigger.handlers[0] 是事件的 initEvent 函数。
然后系统会调用 add(o, '事件名', evtTrigger)
然后把 evtTrigger 保存在 o.data.event['事件名'] 中。
如果 之前已经绑定了这个事件，则 evtTrigger 已存在，无需创建。
这时系统只需把 函数 放到 evtTrigger.handlers 即可。
&lt;/p&gt;
&lt;p&gt;
也就是说，真正的事件触发函数是 evtTrigger， evtTrigger去执行用户定义的一个事件全部函数。
&lt;/p&gt;
&lt;p&gt;
当用户使用  o.un('事件名', 函数)  时， 系统会找到相应 evtTrigger， 并从
evtTrigger.handlers 删除 函数。
如果  evtTrigger.handlers 是空数组， 则使用
remove(o, '事件名', evtTrigger)  移除事件。
&lt;/p&gt;
&lt;p&gt;
当用户使用  o.trigger(参数)  时， 系统会找到相应 evtTrigger， 
如果事件有trigger， 则使用 trigger(对象, '事件名', evtTrigger, 参数) 触发事件。
如果没有， 则直接调用 evtTrigger(参数)。
&lt;/p&gt;
&lt;p&gt;
下面分别介绍各函数的具体内容。
&lt;/p&gt;
&lt;p&gt;
add 表示 事件被绑定时的操作。  原型为: 
&lt;/p&gt;
&lt;code&gt;
function add(elem, type, fn) {
// 对于标准的 DOM 事件， 它会调用 elem.addEventListener(type, fn, false);
}
&lt;/code&gt;
&lt;p&gt;
elem表示绑定事件的对象，即类实例。 type 是事件类型， 它就是事件名，因为多个事件的 add 函数肯能一样的， 因此 type 是区分事件类型的关键。fn 则是绑定事件的函数。
&lt;/p&gt;
&lt;p&gt;
remove 同理。
&lt;/p&gt;
&lt;p&gt;
initEvent 的参数是一个事件参数，它只能有1个参数。
&lt;/p&gt;
&lt;p&gt;
trigger 是高级的事件。参考上面的说明。 
&lt;/p&gt;
&lt;p&gt;
如果你不知道其中的几个参数功能，特别是  trigger ，请不要自定义。
&lt;/p&gt;</remarks>
        <example>下面代码演示了如何给一个类自定义事件，并创建类的实例，然后绑定触发这个事件。
&lt;code&gt;
// 创建一个新的类。
var MyCls = new Class();
MyCls.addEvents({
click: {
add:  function(elem, type, fn) {
alert("为  elem 绑定 事件 " + type );
},
initEvent: function(e) {
alert("初始化 事件参数  " + e );
}
}
});
var m = new MyCls;
m.on('click', function() {
alert(' 事件 触发 ');
});
m.trigger('click', 2);
&lt;/code&gt;</example>
        <returns type="">this</returns>
        <param name="evens" type="Object" defaultvalue="">所有事件。 具体见下。</param>
        <param name="events" type="" />
      </method>
      <method name="extendIf" attribute="static" id="4">
        <summary>如果目标成员不存在就复制对象的所有属性到其它对象。</summary>
        <remarks>&lt;code&gt;
var a = {v: 3, g: 5}, b = {g: 2};
Object.extendIf(a, b);
trace(a); // {v: 3, g: 5}  b 未覆盖 a 任何成员。
&lt;/code&gt;</remarks>
        <seealso cref="Object.extend" />
        <returns type="Object">复制后的对象 (dest)。</returns>
        <param name="dest" type="Object">复制目标。</param>
        <param name="obj" type="Object">要复制的内容。</param>
      </method>
      <method name="each" attribute="static" id="5">
        <summary>在一个可迭代对象上遍历。</summary>
        <example>&lt;code&gt; 
Object.each({a: '1', c: '3'}, function(value, key) {
trace(key + ' : ' + value);
});
// 输出 'a : 1' 'c : 3'
&lt;/code&gt;</example>
        <returns type="Boolean">如果已经遍历完所传的所有值， 返回 true， 如果遍历被中断过，返回 false。</returns>
        <param name="iterable" type="Array/Object">对象，不支持函数。</param>
        <param name="fn" type="Function">对每个变量调用的函数。 &lt;param type="Object" name="value"&gt;当前变量的值&lt;/param&gt; &lt;param type="Number" name="key"&gt;当前变量的索引&lt;/param&gt; &lt;param type="Number" name="index"&gt;当前变量的索引&lt;/param&gt; &lt;param type="Array" name="array"&gt;数组本身&lt;/param&gt; &lt;return type="Boolean"&gt;如果中止循环， 返回 false。&lt;/return&gt;</param>
        <param name="bind" type="Object">函数执行时的作用域。</param>
      </method>
      <method name="update" attribute="static" id="6">
        <summary>更新一个可迭代对象。</summary>
        <example>该函数支持多个功能。主要功能是将一个对象根据一个关系变成新的对象。
&lt;code&gt;
Object.update(["aa","aa23"], "length", []); // =&gt; [2, 4];
Object.update([{a: 1},{a: 4}], "a", [{},{}], true); // =&gt; [{a: 1},{a: 4}];
Object.update(["aa","aa23"], function(value, key, array) {return value.charAt(0);}, []); // =&gt; ["a", "a"];
&lt;/code&gt;</example>
        <returns type="Object">返回的对象。</returns>
        <param name="iterable" type="Object">对象，不支持函数。</param>
        <param name="fn" type="Function">对每个变量调用的函数。 &lt;param type="Object" name="value"&gt;当前变量的值&lt;/param&gt; &lt;param type="Number" name="key"&gt;当前变量的索引&lt;/param&gt; &lt;param type="Array" name="array"&gt;数组本身&lt;/param&gt; &lt;return type="Boolean"&gt;如果中止循环， 返回 false。&lt;/return&gt;</param>
        <param name="bind" type="Array" defaultvalue="iterable">函数执行时的作用域。</param>
        <param name="args" type="Object/Boolean" defaultvalue="">参数/是否间接传递。</param>
        <param name="dest" type="" />
      </method>
      <method name="isObject" attribute="static" id="7">
        <summary>判断一个变量是否是引用变量。</summary>
        <example>&lt;code&gt;
Object.isObject({}); // true
Object.isObject(null); // false
&lt;/code&gt;</example>
        <returns type="Boolean">所有对象变量返回 true, null 返回 false 。</returns>
        <param name="object" type="Object">变量。</param>
        <param name="obj" type="Object" />
      </method>
      <method name="isArray" attribute="static" id="8">
        <summary>判断一个变量是否是数组。</summary>
        <example>&lt;code&gt; 
Object.isArray([]); // true
Object.isArray(document.getElementsByTagName("div")); // false
Object.isArray(new Array); // true
&lt;/code&gt;</example>
        <returns type="Boolean">如果是数组，返回 true， 否则返回 false。</returns>
        <param name="object" type="String/Array">变量。</param>
        <param name="obj" type="Object" />
      </method>
      <method name="isFunction" attribute="static" id="9">
        <summary>判断一个变量是否是函数。</summary>
        <example>&lt;code&gt;
Object.isFunction(function() {}); // true
Object.isFunction(null); // false
Object.isFunction(new Function); // true
&lt;/code&gt;</example>
        <returns type="Boolean">如果是函数，返回 true， 否则返回 false。</returns>
        <param name="object" type="Object">变量。</param>
        <param name="obj" type="Object" />
      </method>
      <method name="type" attribute="static" id="10">
        <summary>返回一个变量的类型的字符串形式。</summary>
        <example>&lt;code&gt; 
Object.type(null); // "null"
Object.type(); // "undefined"
Object.type(new Function); // "function"
Object.type(+'a'); // "number"
Object.type(/a/); // "regexp"
Object.type([]); // "array"
&lt;/code&gt;</example>
        <returns type="String">所有可以返回的字符串：  string  number   boolean   undefined	null	array	function   element  class   date   regexp object。</returns>
        <param name="obj" type="Object">变量。</param>
      </method>
      <method name="clone" attribute="static" id="11">
        <summary>深拷贝一个对象本身, 不深复制函数。</summary>
        <example>&lt;code&gt;
var obj1 = {a: 0, b: 1};
var obj2 = Object.clone(obj1);
obj1.a = 3;
trace(obj1.a);  // trace 3
trace(obj2.a);  // trace 0
&lt;/code&gt;</example>
        <returns type="Object">返回复制后的对象。</returns>
        <param name="obj" type="Object">要拷贝的对象。</param>
      </method>
      <method name="set" attribute="static" id="12">
        <summary>将一个对象解析成一个类的属性。</summary>
        <remarks>这个函数会分析对象，并试图找到一个 属性设置函数。
当设置对象 obj 的 属性 key 为 value:
发生了这些事:
检查，如果存在就调用: obj.setKey(value)
否则， 检查，如果存在就调用: obj.key(value)
否则， 检查，如果存在就调用: obj.key.set(value)
否则，检查，如果存在就调用: obj.set(value)
否则，执行 obj.key = value;</remarks>
        <example>&lt;code&gt;
document.setA = function(value) {
this._a = value;
};
Object.set(document, 'a', 3); 
// 这样会调用     document.setA(3);
&lt;/code&gt;</example>
        <returns type="void" />
        <param name="obj" type="Object">类实例。</param>
        <param name="config" type="Object">参数。</param>
      </method>
      <method name="addCallback" attribute="static" id="13">
        <summary>添加一个对象的成员函数调用结束后的回调函数。</summary>
        <example>下面的代码方便地添加 onload 事件。 
&lt;code&gt;
Object.addCallback(window, "onload",trace.empty);
&lt;/code&gt;</example>
        <returns type="Object">obj。</returns>
        <param name="obj" type="Object">对象。</param>
        <param name="name" type="String">成员函数名。</param>
        <param name="fn" type="Function">对象。</param>
      </method>
      <method name="base" access="protected" id="14">
        <summary>调用父类的成员变量。</summary>
        <remarks>注意只能从子类中调用父类的同名成员。</remarks>
        <example>&lt;code&gt;
var MyBa = new Class({
a: function(g, b) {
alert(g + b);
}
});
var MyCls = MyBa.extend({
a: function(g, b) {
this.base('a', g, b);   // 或   this.base('a', arguments);
}
});
new MyCls().a();   
&lt;/code&gt;</example>
        <returns type="Object">父类返回。</returns>
        <param name="name" type="String">属性名。</param>
        <param name="..." type="Object">调用的参数数组。</param>
        <param name="args" type="" />
      </method>
      <method name="memberwiseClone" access="protected" id="15">
        <summary>创建当前 Object 的浅表副本。</summary>
        <example>&lt;code&gt;
var MyBa = new Class({
clone: function() {
return this.memberwiseClone();
}
});
&lt;/code&gt;</example>
        <returns type="Object">当前变量的副本。</returns>
      </method>
    </class>
    <class name="Function" source="-1">
      <property type="Function" name="empty" attribute="static">
        <summary>空函数。</summary>
        <remarks>Function.empty返回空函数的引用。</remarks>
      </property>
      <property type="Function" name="returnTrue" attribute="static">
        <summary>一个返回 true 的函数。</summary>
      </property>
      <property type="Function" name="returnFalse" attribute="static">
        <summary>一个返回 false 的函数。</summary>
      </property>
      <method name="bind" attribute="static">
        <summary>绑定函数作用域。</summary>
        <remarks>注意，未来 Function.prototype.bind 是系统函数， 因此这个函数将在那个时候被 替换掉。</remarks>
        <example>&lt;code&gt;
Function.bind(function() {return this}, 0)()    ; // 0
&lt;/code&gt;</example>
        <returns type="Function" />
        <param name="fn" type="Function">函数。</param>
        <param name="bind" type="Object">位置。</param>
      </method>
      <method name="from" attribute="static">
        <summary>返回自身的函数。</summary>
        <example>&lt;code&gt;
Function.from(0)()    ; // 0
&lt;/code&gt;</example>
        <returns type="Function">执行得到参数的一个函数。</returns>
        <param name="v" type="Object">需要返回的参数。</param>
        <param name="obj" type="Object" />
      </method>
    </class>
    <class name="RegExp" source="-1">
      <field type="String" name="xType">
        <summary>xType。</summary>
      </field>
    </class>
    <class name="Array" source="-1">
      <method name="create" attribute="static">
        <summary>在原有可迭代对象生成一个数组。</summary>
        <example>&lt;code&gt;
Array.create([4,6], 1); // [6]
&lt;/code&gt;</example>
        <returns type="Array">复制得到的数组。</returns>
        <param name="iterable" type="Object">可迭代的实例。</param>
        <param name="start" type="Number" defaultvalue="0">开始的位置。</param>
      </method>
      <method name="copyIf" attribute="static">
        <summary>如果目标数组不存在值，则拷贝，否则忽略。</summary>
        <example>&lt;code&gt;
Array.copyIf([4,6], [4, 7]); // [4, 7, 6]
&lt;/code&gt;</example>
        <returns type="void" />
        <param name="src" type="Object">来源数组。</param>
        <param name="dest" type="Array">目标数组。</param>
      </method>
      <method name="plain" attribute="static">
        <summary>把传入的值连接为新的数组。如果元素本身是数组，则合并。此函数会过滤存在的值。</summary>
        <example>&lt;code&gt;
Array.plain([4,6], [[4], 7]); // [4, 7, 6]
&lt;/code&gt;</example>
        <returns type="Array">新数组。</returns>
        <param name="..." type="Object">数据成员。</param>
      </method>
      <method name="forEach">
        <summary>对数组内的所有变量执行函数，并可选设置作用域。</summary>
        <seealso cref="Array.prototype.each" />
        <example>&lt;code&gt; 
[2, 5].forEach(function(value, key) {
trace(value);
});
// 输出 '2' '5'
&lt;/code&gt;</example>
        <returns type="void" />
        <param name="fn" type="Function">对每个变量调用的函数。 &lt;param type="Object" name="value"&gt;当前变量的值&lt;/param&gt; &lt;param type="Number" name="key"&gt;当前变量的索引&lt;/param&gt; &lt;param type="Number" name="index"&gt;当前变量的索引&lt;/param&gt; &lt;param type="Array" name="array"&gt;数组本身&lt;/param&gt;</param>
        <param name="bind" type="Object">函数执行时的作用域。</param>
      </method>
      <method name="indexOf">
        <summary>返回数组某个值的第一个位置。值没有,则为-1 。</summary>
        <remarks>现在大多数浏览器已含此函数.除了 IE8-  。</remarks>
        <returns type="">Number 位置，找不到返回 -1 。</returns>
        <param name="item" type="Object">成员。</param>
        <param name="start" type="Number" defaultvalue="0">开始查找的位置。</param>
        <param name="startIndex" type="" />
      </method>
      <method name="each">
        <summary>对数组运行一个函数。</summary>
        <seealso cref="Array.prototype.forEach" />
        <example>&lt;code&gt; 
[2, 5].each(function(value, key) {
trace(value);
return false
});
// 输出 '2'
&lt;/code&gt;</example>
        <returns type="Boolean">有无执行完。</returns>
        <param name="fn" type="Function">函数.参数 value, index</param>
        <param name="bind" type="Object">对象。</param>
      </method>
      <method name="filter">
        <summary>对数组每个元素通过一个函数过滤。返回所有符合要求的元素的数组。</summary>
        <seealso cref="Array.prototype.select" />
        <example>&lt;code&gt; 
[1, 7, 2].filter(function(key) {return key &amp;lt; 5 })   [1, 2]
&lt;/code&gt;</example>
        <returns type="Array">新的数组。</returns>
        <param name="fn" type="Function">函数。参数 value, index, this。</param>
        <param name="bind" type="Object">绑定的对象。</param>
      </method>
      <method name="select">
        <summary>对数组每个元素筛选出一个函数返回true或属性符合的项。</summary>
        <seealso cref="Array.prototype.filter" />
        <example>&lt;code&gt;
["", "aaa", "zzz", "qqq"].select("length", 0); //  [""];
[{q: "1"}, {q: "3"}].select("q", "3");	//  返回   [{q: "3"}];
[{q: "1"}, {q: "3"}].select(function(v) {
return v.["q"] == "3";
});	//  返回   [{q: "3"}];
&lt;/code&gt;</example>
        <returns type="">this</returns>
        <param name="name" type="Function/String">函数。 &lt;param type="Object" name="value"&gt;当前变量的值&lt;/param&gt; &lt;param type="Number" name="key"&gt;当前变量的索引&lt;/param&gt; &lt;param type="Number" name="index"&gt;当前变量的索引&lt;/param&gt; &lt;param type="Array" name="array"&gt;数组本身&lt;/param&gt; /数组成员的字段。</param>
        <param name="value" type="Object">值。</param>
      </method>
      <method name="include">
        <summary>包含一个元素。元素存在直接返回。</summary>
        <example>&lt;code&gt;
["", "aaa", "zzz", "qqq"].include(""); //   true
[false].include(0);	//   false
&lt;/code&gt;</example>
        <returns type="Boolean">是否包含元素。</returns>
        <param name="value" type="Object">值。</param>
      </method>
      <method name="insert">
        <summary>在指定位置插入项。</summary>
        <example>&lt;code&gt;
["", "aaa", "zzz", "qqq"].insert(3, 4); //   ["", "aaa", "zzz", 4, "qqq"]
&lt;/code&gt;</example>
        <returns type="Object" />
        <param name="index" type="Number">插入的位置。</param>
        <param name="value" type="Object">插入的内容。</param>
      </method>
      <method name="invoke">
        <summary>对数组成员遍历执行。</summary>
        <example>&lt;code&gt;
["vhd"].invoke('charAt', [0]); //    ['v']
&lt;/code&gt;</example>
        <returns type="Array">结果。</returns>
        <param name="fn" type="String/Function" />
        <param name="args" type="Array" />
      </method>
      <method name="unique">
        <summary>删除数组中重复元素。</summary>
        <example>&lt;code&gt;
[1,7,8,8].unique(); //    [1, 7, 8]
&lt;/code&gt;</example>
        <returns type="Array">结果。</returns>
      </method>
      <method name="remove">
        <summary>删除元素, 参数为元素的内容。</summary>
        <example>&lt;code&gt;
[1,7,8,8].remove(7); //   1
&lt;/code&gt;</example>
        <returns type="Number">删除的值的位置。</returns>
        <param name="value" type="Object">值。</param>
      </method>
      <field type="String" name="xType">
        <summary>xType。</summary>
      </field>
    </class>
    <class name="Date" source="-1">
      <method name="now" attribute="static">
        <summary>获取当前时间。</summary>
        <example>&lt;code&gt;
Date.now(); //   相当于 new Date().getTime()
&lt;/code&gt;</example>
        <returns type="Number">当前的时间点。</returns>
      </method>
      <field type="String" name="xType">
        <summary>xType。</summary>
      </field>
    </class>
    <dynatic name="document">
      <field type="Object" name="document" source="-1">
        <summary>表示一个事件接口。</summary>
        <remarks>Py.IEvent 提供了事件机制的基本接口，凡实现这个接口的类店都有事件的处理能力。
在调用  &lt;link&gt;Py.Object.addEvents&lt;/link&gt; 的时候，将自动实现这个接口。</remarks>
      </field>
      <members>
        <method name="onReady">
          <summary>页面加载时执行。</summary>
          <returns type="void" />
          <param name="fn" type="Functon">执行的函数。</param>
        </method>
        <method name="onLoad">
          <summary>在文档载入的时候执行函数。</summary>
          <returns type="void" />
          <param name="fn" type="Functon">执行的函数。</param>
        </method>
      </members>
    </dynatic>
    <dynatic name="trace">
      <method name="trace">
        <summary>调试输出。</summary>
        <returns type="void" />
        <param name="obj" type="String">值。</param>
        <param name="args" type="Object">格式化的字符串。</param>
      </method>
      <members>
        <method name="error">
          <summary>输出一个错误信息。</summary>
          <returns type="void" />
          <param name="msg" type="String">内容。</param>
        </method>
        <method name="inspect">
          <summary>获取对象的所有成员的字符串形式。</summary>
          <returns type="">String 成员。</returns>
          <param name="obj" type="Undefined">要输出的内容。</param>
          <param name="deep" type="Number/undefined">递归的层数。</param>
        </method>
        <method name="alert">
          <summary>输出方式。</summary>
          <returns type="void" />
          <param name="message" type="String">信息。</param>
        </method>
        <method name="dir">
          <summary>遍历对象每个元素。</summary>
          <returns type="void" />
          <param name="obj" type="Object">对象。</param>
        </method>
        <method name="api">
          <summary>输出类的信息。</summary>
          <returns type="void" />
          <param name="成员" type="Object">。</param>
          <param name="obj" type="Object" />
        </method>
        <method name="from">
          <summary>得到输出指定内容的函数。</summary>
          <returns type="Function" />
          <param name="msg" type="" />
        </method>
        <method name="log">
          <summary>输出信息。</summary>
          <returns type="void" />
          <param name="..." type="Object">内容。</param>
        </method>
        <method name="warn">
          <summary>输出一个警告信息。</summary>
          <returns type="void" />
          <param name="msg" type="Object">内容。</param>
        </method>
        <method name="info">
          <summary>输出一个信息。</summary>
          <returns type="void" />
          <param name="msg" type="Object">内容。</param>
        </method>
        <method name="ifDebug">
          <summary>如果是调试模式就运行。</summary>
          <returns type="">String 返回运行的错误。如无错, 返回空字符。</returns>
          <param name="f" type="Function">函数。</param>
        </method>
        <method name="clear">
          <summary>清除调试信息。  (没有控制台时，不起任何作用)</summary>
          <returns type="void" />
        </method>
        <method name="empty">
          <summary>空函数，用于证明函数已经执行过。</summary>
          <returns type="void" />
          <param name="msg" type="" />
        </method>
        <method name="ifNot">
          <summary>如果false则输出。</summary>
          <returns type="String">msg  输出的内容。</returns>
          <param name="condition" type="Boolean">字段。</param>
          <param name="msg" type="" />
        </method>
        <method name="runTime">
          <summary>测试某个函数运行一定次数的时间。</summary>
          <returns type="Number">运行的时间 。</returns>
          <param name="fn" type="Function">函数。</param>
          <param name="args" type="Array">函数参数。</param>
          <param name="times" type="Number" defaultvalue="1000">运行次数。</param>
        </method>
        <method name="test">
          <summary>输出一个函数执行指定次使用的时间。</summary>
          <returns type="void" />
          <param name="fn" type="Function">函数。</param>
          <param name="times" type="Number" defaultvalue="1000">运行次数。</param>
        </method>
      </members>
    </dynatic>
    <dynatic name="assert">
      <method name="assert">
        <summary>确认一个值正确。</summary>
        <example>&lt;code&gt;
assert(true, "{value} 错误。", value
&lt;/code&gt;</example>
        <returns type="Boolean">返回 bValue 。</returns>
        <param name="bValue" type="Object">值。</param>
        <param name="msg" type="Undefined" defaultvalue="&quot;断言失败&quot;">错误后的提示。</param>
        <param name="" type="Object" />
      </method>
      <members>
        <method name="isObject">
          <summary>确认一个值为函数变量。</summary>
          <returns type="Boolean">返回 bValue 。</returns>
          <param name="bValue" type="Object">值。</param>
          <param name="msg" type="String" defaultvalue="&quot;断言失败&quot;">错误后的提示。</param>
          <param name="value" type="" />
        </method>
        <method name="notNull">
          <summary>确认一个值非空。</summary>
          <returns type="Boolean">返回 assert 是否成功 。</returns>
          <param name="value" type="Object">值。</param>
          <param name="argsName" type="String">变量的名字字符串。</param>
          <param name="msg" type="" />
        </method>
        <method name="isFunction">
          <summary>确认一个值为函数变量。</summary>
          <example>&lt;code&gt;
assert.isFunction(a, "a ~");
&lt;/code&gt;</example>
          <returns type="Boolean">返回 bValue 。</returns>
          <param name="bValue" type="Object">值。</param>
          <param name="msg" type="String" defaultvalue="&quot;断言失败&quot;">错误后的提示。</param>
        </method>
        <method name="isString">
          <summary>确认一个值是字符串。</summary>
          <returns type="Boolean">返回 bValue 。</returns>
          <param name="bValue" type="Object">值。</param>
          <param name="msg" type="String" defaultvalue="&quot;断言失败&quot;">错误后的提示。</param>
          <param name="value" type="" />
        </method>
        <method name="isNumber">
          <summary>确认一个值为数字。</summary>
          <returns type="Boolean">返回 bValue 。</returns>
          <param name="bValue" type="Object">值。</param>
          <param name="msg" type="String" defaultvalue="&quot;断言失败&quot;">错误后的提示。</param>
          <param name="value" type="" />
        </method>
        <method name="isArray">
          <summary>确认一个值为数组。</summary>
          <returns type="Boolean">返回 bValue 。</returns>
          <param name="bValue" type="Object">值。</param>
          <param name="msg" type="String" defaultvalue="&quot;断言失败&quot;">错误后的提示。</param>
        </method>
        <method name="isNode">
          <summary>确认一个值为节点。</summary>
          <returns type="Boolean">返回 bValue 。</returns>
          <param name="bValue" type="Object">值。</param>
          <param name="msg" type="String" defaultvalue="&quot;断言失败&quot;">错误后的提示。</param>
          <param name="value" type="" />
        </method>
        <method name="isElement">
          <summary>确认一个值为节点。</summary>
          <returns type="Boolean">返回 bValue 。</returns>
          <param name="bValue" type="Object">值。</param>
          <param name="msg" type="String" defaultvalue="&quot;断言失败&quot;">错误后的提示。</param>
          <param name="value" type="" />
        </method>
        <method name="isDate">
          <summary>确认一个值是日期。</summary>
          <returns type="Boolean">返回 bValue 。</returns>
          <param name="bValue" type="Object">值。</param>
          <param name="msg" type="String" defaultvalue="&quot;断言失败&quot;">错误后的提示。</param>
          <param name="value" type="" />
        </method>
        <method name="isRegExp">
          <summary>确认一个值是正则表达式。</summary>
          <returns type="Boolean">返回 bValue 。</returns>
          <param name="bValue" type="Object">值。</param>
          <param name="msg" type="String" defaultvalue="&quot;断言失败&quot;">错误后的提示。</param>
          <param name="value" type="" />
        </method>
        <method name="between">
          <summary>确认一个值在 min ， max 间。</summary>
          <returns type="Boolean">返回 assert 是否成功 。</returns>
          <param name="value" type="Number">判断的值。</param>
          <param name="min" type="Number">最小值。</param>
          <param name="max" type="Number">最大值。</param>
          <param name="argsName" type="String">变量的米各庄。</param>
          <param name="msg" type="" />
        </method>
        <method name="instanceOf">
          <summary>确认一个值属于一个类型。</summary>
          <returns type="Boolean">返回 assert 是否成功 。</returns>
          <param name="v" type="Object">值。</param>
          <param name="types" type="String/Array">类型/表示类型的参数数组。</param>
          <param name="message" type="String">错误的提示信息。</param>
          <param name="msg" type="" />
        </method>
        <method name="notEmpty">
          <summary>确认一个值非空。</summary>
          <returns type="Boolean">返回 assert 是否成功 。</returns>
          <param name="value" type="Object">值。</param>
          <param name="argsName" type="String">变量的参数名。</param>
          <param name="msg" type="" />
        </method>
      </members>
    </dynatic>
    <namespace name="Py">
      <config type="Boolean" name="debug">
        <summary>是否打开调试。</summary>
      </config>
      <config type="String" name="rootPath">
        <summary>PyJs 安装的根目录, 可以为相对目录。</summary>
        <remarks>程序会自动搜索当前脚本的位置为跟目录。</remarks>
      </config>
      <config type="Boolean" defaultvalue="false" name="stackTrace">
        <summary>是否输出 assert 来源。</summary>
        <remarks>如果此项是 true， 将会输出 assert 失败时的来源函数。</remarks>
      </config>
      <config type="Object" defaultvalue="window" name="defaultNamespace">
        <summary>默认的全局名字空间。</summary>
      </config>
      <config type="String" defaultvalue="'default'" name="theme">
        <summary>如果使用了 UI 库，则 theme 表示默认主题。</summary>
      </config>
      <config type="String" defaultvalue="'share'" name="resource">
        <summary>如果使用了 UI 库，则  resource 表示公共的主题资源。</summary>
      </config>
      <config type="Boolean" name="trace">
        <summary>启用控制台调试。</summary>
        <remarks>如果不存在控制台，将自动调整为 false 。</remarks>
      </config>
      <dynatic name="Events" access="private">
        <property type="Object" name="Events" access="private" attribute="static">
          <summary>管理所有事件类型的工具。</summary>
          <remarks>所有类的事件信息存储在这个变量。使用 xType -&gt; name的结构。</remarks>
        </property>
        <members>
          <field type="Object" name="$default">
            <summary>管理默认的类事件。</summary>
            <remarks>Py.IEvent 提供了事件机制的基本接口，凡实现这个接口的类店都有事件的处理能力。
在调用  &lt;link&gt;Py.Object.addEvents&lt;/link&gt; 的时候，将自动实现这个接口。</remarks>
          </field>
        </members>
      </dynatic>
      <method name="data" attribute="static">
        <summary>获取属于一个元素的数据。</summary>
        <remarks>这个函数会在对象内生成一个 data 字段， 并生成一个 data.type 对象返回。
如果原先存在 data.type, 则直接返回。</remarks>
        <example>&lt;code&gt;
var obj = {};
Py.data(obj, 'a').c = 2;
trace(  Py.data(obj, 'a').c  ) // 2
&lt;/code&gt;</example>
        <returns type="Object">值。</returns>
        <param name="obj" type="Object">元素。</param>
        <param name="type" type="String">类型。</param>
      </method>
      <method name="dataIf" attribute="static">
        <summary>如果存在，获取属于一个元素的数据。</summary>
        <remarks>这个函数会在对象内生成一个 data 字段， 并生成一个 data.type 对象返回。
如果原先存在 data.type, 则直接返回。</remarks>
        <example>&lt;code&gt;
var obj = {};
if(Py.dataIf(obj, 'a')) // 如果存在 a 属性。 
trace(  Py.data(obj, 'a')  )
&lt;/code&gt;</example>
        <returns type="Object">值。</returns>
        <param name="obj" type="Object">元素。</param>
        <param name="type" type="String">类型。</param>
      </method>
      <method name="setData" attribute="static">
        <summary>设置属于一个元素的数据。</summary>
        <example>&lt;code&gt;
var obj = {};
Py.setData(obj, 'a', 5);    //     5
&lt;/code&gt;</example>
        <returns type="">data</returns>
        <param name="obj" type="Object">元素。</param>
        <param name="type" type="String">类型。</param>
        <param name="data" type="Object">内容。</param>
      </method>
      <method name="cloneData" attribute="static">
        <summary>复制一个对象的数据到另一个对象。</summary>
        <example>&lt;code&gt;
var obj = {}, obj2 = {};
Py.cloneData(obj2, obj);
&lt;/code&gt;</example>
        <returns type="">this</returns>
        <param name="src" type="Object">来源的对象。</param>
        <param name="dest" type="Object">目标的对象。</param>
      </method>
      <field type="Array" name="namespaces" access="private" attribute="static">
        <summary>全部已载入的名字空间。</summary>
      </field>
      <method name="loadStyle" attribute="static">
        <summary>异步载入样式。</summary>
        <example>&lt;code&gt;
Py.loadStyle('./v.css');
&lt;/code&gt;</example>
        <returns type="void" />
        <param name="uri" type="String">地址。</param>
        <param name="url" type="" />
      </method>
      <method name="loadScript" attribute="static">
        <summary>同步载入代码。</summary>
        <example>&lt;code&gt;
Py.loadScript('./v.js');
&lt;/code&gt;</example>
        <returns type="void" />
        <param name="uri" type="String">地址。</param>
        <param name="url" type="" />
      </method>
      <method name="loadText">
        <summary>同步载入文本。</summary>
        <remarks>因为同步，所以无法跨站。</remarks>
        <example>&lt;code&gt;
trace(  Py.loadText('./v.html')  );
&lt;/code&gt;</example>
        <returns type="String">载入的值。</returns>
        <param name="uri" type="String">地址。</param>
        <param name="callback" type="Function" defaultvalue="">对返回值的处理函数。</param>
        <param name="url" type="" />
      </method>
      <method name="eval" attribute="static">
        <summary>全局运行一个函数。</summary>
        <example>&lt;code&gt;
Py.eval('alert("hello")');
&lt;/code&gt;</example>
        <returns type="Object">执行返回值。</returns>
        <param name="statement" type="String">语句。</param>
      </method>
      <method name="Class" attribute="static">
        <summary>创建一个类。</summary>
        <remarks>创建一个类，相当于继承于 Py.Object创建。</remarks>
        <see cref="Py.Object.extend" />
        <example>&lt;code&gt;
var MyCls = Class({
constructor: function(g, h) {
alert('构造函数' + g + h)
}	
});
var c = new MyCls(4, ' g');
&lt;/code&gt;</example>
        <returns type="Class">生成的类。</returns>
        <param name="methods" type="Object/Function" defaultvalue="">成员或构造函数。</param>
        <param name="members" type="" />
      </method>
      <interface name="IEvent">
        <summary>表示一个事件接口。</summary>
        <remarks>Py.IEvent 提供了事件机制的基本接口，凡实现这个接口的类店都有事件的处理能力。
在调用  &lt;link&gt;Py.Object.addEvents&lt;/link&gt; 的时候，将自动实现这个接口。</remarks>
        <method name="on" attribute="static">
          <summary>增加一个监听者。</summary>
          <example>&lt;code&gt;
elem.on('click', function(e) {
return true;
});
&lt;/code&gt;</example>
          <returns type="">Object this</returns>
          <param name="type" type="String">监听名字。</param>
          <param name="fn" type="Function">调用函数。</param>
        </method>
        <method name="one" attribute="static">
          <summary>增加一个只执行一次的监听者。</summary>
          <example>&lt;code&gt;
elem.one('click', function(e) {
trace('a');  
});
elem.trigger('click');   //  输出  a
elem.trigger('click');   //  没有输出 
&lt;/code&gt;</example>
          <returns type="">Object this</returns>
          <param name="type" type="String">监听名字。</param>
          <param name="fn" type="Function">调用函数。</param>
        </method>
        <method name="un" attribute="static">
          <summary>删除一个监听器。</summary>
          <remarks>注意: function() {} !== function() {}, 这意味着这个代码有问题:
&lt;code&gt;
elem.on('click', function() {});
elem.un('click', function() {});
&lt;/code&gt;
你应该把函数保存起来。
&lt;code&gt;
var c =  function() {};
elem.on('click', c);
elem.un('click', c);
&lt;/code&gt;</remarks>
          <example>&lt;code&gt;
elem.un('click', function(e) {
return true;
});
&lt;/code&gt;</example>
          <returns type="">Object this</returns>
          <param name="type" type="String" defaultvalue="">监听名字。</param>
          <param name="fn" type="Function/undefined">回调器。</param>
        </method>
        <method name="trigger" attribute="static">
          <summary>触发一个监听器。</summary>
          <remarks>trigger 只是手动触发绑定的事件。</remarks>
          <example>&lt;code&gt;
elem.trigger('click');
&lt;/code&gt;</example>
          <returns type="">Object this</returns>
          <param name="type" type="String">监听名字。</param>
          <param name="e" type="Object/undefined">事件参数。</param>
        </method>
      </interface>
      <class name="Object">
        <summary>所有类的基类。</summary>
        <link name="extend" target="0" />
        <link name="implement" target="1" />
        <link name="implementIf" target="2" />
        <link name="addEvents" target="3" />
        <link name="extendIf" target="4" />
        <link name="each" target="5" />
        <link name="update" target="6" />
        <link name="isObject" target="7" />
        <link name="isArray" target="8" />
        <link name="isFunction" target="9" />
        <link name="type" target="10" />
        <link name="clone" target="11" />
        <link name="set" target="12" />
        <link name="addCallback" target="13" />
        <link name="base" target="14" />
        <link name="memberwiseClone" target="15" />
      </class>
      <method name="using" attribute="static">
        <summary>使用一个名空间。</summary>
        <remarks>有关名字空间的说明， 见 &lt;link&gt;namespace&lt;/link&gt; 。</remarks>
        <example>&lt;code&gt;
using("System.Dom.Keys");
&lt;/code&gt;</example>
        <returns type="void" />
        <param name="namespace" type="String">名字空间。</param>
        <param name="isStyle" type="Boolean">是否为样式表。</param>
      </method>
      <method name="namespace" attribute="static">
        <summary>定义名字空间。</summary>
        <remarks>&lt;p&gt;
名字空间是项目中表示资源的符合。
&lt;/p&gt;
&lt;p&gt;
比如  system/dom/keys.js 文件， 名字空间是 System.Dom.Keys
名字空间用来快速表示资源。 &lt;link&gt;using&lt;/link&gt; 和  &lt;link&gt;imports&lt;/link&gt; 可以根据制定的名字空间载入相应的内容。
&lt;/p&gt;
&lt;p&gt;
namespace 函数有多个重载， 如果只有1个参数:
&lt;code&gt;
namespace("System.Dom.Keys"); 
&lt;/code&gt;
表示系统已经载入了这个名字空间的资源， using 和 imports 将忽视这个资源的载入。
&lt;/p&gt;
&lt;p&gt;
namespace 如果有2个参数， 表示在指定的位置创建对象。
&lt;code&gt;
namespace("A.B.C", 5); // 最后 A = {B: {C: 5}}  
&lt;/code&gt;
这个写法最后覆盖了 C 的值，但不影响 A 和 B。 
&lt;p&gt;
如果这个名字空间的首字符是 . 则系统会补上 'Py'
&lt;/p&gt; 
&lt;p&gt;
如果这个名字空间的最后的字符是 . 则系统不会覆盖已有对象，而是复制成员到存在的成员。
&lt;/p&gt; 
&lt;/p&gt;</remarks>
        <example>&lt;code&gt;
namespace("System.Dom.Keys");  // 避免 重新去引入   System.Dom.Keys
var A = {   B:  {b: 5},  C: {b: 5}    };
namespace("A.B", {a: 6})  // A = { B: {a: 6}, C: {b: 5}  }
var A = {   B:  {b: 5},  C: {b: 5}    };
namespace("A.C.", {a: 6})  // A = { B: {b: 5},  C: {a: 6, b: 5} }
namespace(".G", 4);    // Py.G = G  = 4
&lt;/code&gt;</example>
        <returns type="void" />
        <param name="name" type="String">名字空间。</param>
        <param name="obj" type="Object" defaultvalue="">值。</param>
      </method>
      <method name="addEventListener" attribute="static">
        <summary>绑定一个监听器。</summary>
        <seealso cref="Py.removeListener" />
        <example>&lt;code&gt;
Py.addEventListener.call(document, 'click', function() {
});
&lt;/code&gt;</example>
        <returns type="void" />
        <param name="elem" type="Element">元素。</param>
        <param name="type" type="String">类型。</param>
        <param name="fn" type="Function">函数。</param>
      </method>
      <method name="removeEventListener" attribute="static">
        <summary>移除一个监听器。</summary>
        <seealso cref="Py.addListener" />
        <example>&lt;code&gt;
Py.removeEventListener.call(document, 'click', function() {
});
&lt;/code&gt;</example>
        <returns type="void" />
        <param name="elem" type="Element">元素。</param>
        <param name="type" type="String">类型。</param>
        <param name="fn" type="Function">函数。</param>
      </method>
      <field type="Number" name="id">
        <summary>id种子 。</summary>
      </field>
      <method name="setupWindow" access="private">
        <summary>初始化 window 对象。</summary>
        <returns type="void" />
        <param name="doc" type="Document" />
        <param name="w" type="" />
      </method>
    </namespace>
    <namespace name="navigator">
      <summary>浏览器。</summary>
      <property propertyaccess="1" type="Boolean" name="isIE">
        <summary>获取一个值，该值指示是否为 IE 浏览器。</summary>
      </property>
      <property propertyaccess="1" type="Boolean" name="isFirefox">
        <summary>获取一个值，该值指示是否为 Firefox 浏览器。</summary>
      </property>
      <property propertyaccess="1" type="Boolean" name="isChrome">
        <summary>获取一个值，该值指示是否为 Chrome 浏览器。</summary>
      </property>
      <property propertyaccess="1" type="Boolean" name="isOpera">
        <summary>获取一个值，该值指示是否为 Opera 浏览器。</summary>
      </property>
      <property propertyaccess="1" type="Boolean" name="isSafari">
        <summary>获取一个值，该值指示是否为 Safari 浏览器。</summary>
      </property>
      <field type="String" name="browser">
        <summary>浏览器信息。</summary>
      </field>
      <field type="String" name="version">
        <summary>浏览器版本。</summary>
        <remarks>输出的格式比如 6.0</remarks>
      </field>
      <field type="Boolean" name="isQuirks">
        <summary>浏览器是否为标准事件。就目前浏览器状况， IE6，7 中 isQuirks = true  其它皆 false 。</summary>
        <remarks>此处认为 IE6,7 是怪癖的。</remarks>
      </field>
      <field type="Boolean" name="isStd">
        <summary>是否为标准浏览器事件。</summary>
      </field>
      <field type="String" name="fullBrowser">
        <summary>浏览器详细信息。</summary>
      </field>
    </namespace>
    <class name="XMLHttpRequest">
      <summary>生成一个请求。</summary>
      <method name="isOk" attribute="static">
        <summary>判断当前请求是否有正常的返回。</summary>
        <returns type="Boolean">正常返回true 。</returns>
        <param name="xmlHttp" type="XMLHttpRequest">请求。</param>
      </method>
    </class>
  </members>
</doc>